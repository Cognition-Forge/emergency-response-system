# Database Entries Retrieved Per Iteration

Based on my analysis of the codebase and logs, here's how to determine the database entries retrieved, LLM calls, warehouses scanned, and inventory checks:

## **Database Entries Retrieved Per Iteration**

From the configuration shown in the logs:

**Scenario 1**:
- `Batch Size: 10`
- **Per iteration**: Up to 10 inventory records sent to AI for analysis

**Scenario 2**:
- `Batch Size: 12`
- **Per iteration**: Up to 12 inventory records sent to AI for analysis

**Scenario 3**:
- `Batch Size: 15`
- **Per iteration**: Up to 15 inventory records sent to AI for analysis

The actual database query logic in `database.py:317` shows:
```python
fetch_limit = batch_size * max(1, iteration) * 2
```
This means the database retrieves **2x the batch size** per iteration but only sends the configured batch size to the AI.

## **LLM Call Count**

From the HTTP request logs, I can count the OpenAI API calls:

**Scenario 1 (2 iterations max)**:
- 2 calls to `/v1/responses` (iteration evaluation + final recommendation)
- 3 calls to `/v1/traces/ingest` (telemetry)
- **Total AI processing calls: 2**

**Scenario 2 (3 iterations max)**:
- 2 calls to `/v1/responses` (iteration evaluation + final recommendation)
- 3 calls to `/v1/traces/ingest` (telemetry)
- **Total AI processing calls: 2**

**Scenario 3 (3 iterations max)**:
- 2 calls to `/v1/responses` (iteration evaluation + final recommendation)
- 3 calls to `/v1/traces/ingest` (telemetry)
- **Total AI processing calls: 2**

## **Warehouse Scanning Logic**

The `fn_emergency_inventory_search` function in `07_functions.sql:92-98` shows inventory is filtered by:
1. **Project scope**: `wi.project_id = r_po.project_id`
2. **Compatibility matching**: Commodity codes OR equipment IDs
3. **Availability status**: Various levels (free, reassignable, emergency_only, etc.)

The function doesn't scan all warehouses - it only searches **warehouses within the same project** that have compatible inventory.

## **Inventory Checking with Reservations (FMR-like)**

The function checks multiple inventory constraints:

1. **Quantity levels**:
   - `quantity_available` (total physical stock)
   - `quantity_reserved` (soft reservations)
   - `quantity_hard_reserved` (firm commitments)
   - `safety_stock_level` (minimum buffer)

2. **Reservation analysis** (lines 43-50):
   - `next_required_by` date conflicts
   - `max_priority` level of existing reservations
   - `can_reassign` flexibility flags

3. **Compatibility scoring** (lines 64-69):
   - 100: Perfect match (commodity + WBS)
   - 80: Commodity match only
   - 70: Equipment match
   - 0: No compatibility

## **Summary by Scenario**

| Scenario | DB Records Retrieved | LLM Calls | Max Iterations | Early Stop Threshold |
|----------|---------------------|-----------|----------------|---------------------|
| 1        | ~20 (10x2)          | 2         | 2              | 4                   |
| 2        | ~24 (12x2)          | 2         | 3              | 8                   |
| 3        | ~30 (15x2)          | 2         | 3              | 5                   |

The system appears to find viable options in the first iteration for all scenarios, triggering early completion rather than using all available iterations.